# -*- python -*-

import ackward as akw

def definition():
    c = akw.Class(name='UUID',
                  wrapped_class='uuid.UUID')

    akw.Property(
        cls=c,
        name='bytes',
        type='std::string',
        read_only=True)

    akw.Property(
        cls=c,
        name='bytes_le',
        type='std::string',
        read_only=True)

    akw.Property(
        cls=c,
        name='hex',
        type='std::string',
        read_only=True)

    # akw.Property(
    #     cls=c,
    #     name='integer',
    #     type='uint128_t',
    #     read_only=True)

    akw.Property(
        cls=c,
        name='urn',
        type='std::string',
        read_only=True)

    # akw.Property(
    #     cls=c,
    #     name='variant',
    #     type='ackward::uuid::Variant',
    #     read_only=True)

    akw.Property(
        cls=c,
        name='variant',
        type='ackward::uuid::Variant',
        read_only=True)

    akw.Property(
        cls=c,
        name='_version',
        python_name='version',
        type='uint8_t',
        read_only=True)
# UUID.version
# The UUID version number (1 through 5, meaningful only when the variant is RFC_4122).

    return c

'''class uuid.UUID([hex[, bytes[, bytes_le[, fields[, int[, version]]]]]])

Create a UUID from either a string of 32 hexadecimal digits, a string of 16 bytes as the bytes argument, a string of 16 bytes in little-endian order as the bytes_le argument, a tuple of six integers (32-bit time_low, 16-bit time_mid, 16-bit time_hi_version, 8-bit clock_seq_hi_variant, 8-bit clock_seq_low, 48-bit node) as the fields argument, or a single 128-bit integer as the int argument. When a string of hex digits is given, curly braces, hyphens, and a URN prefix are all optional. For example, these expressions all yield the same UUID:

UUID('{12345678-1234-5678-1234-567812345678}')
UUID('12345678123456781234567812345678')
UUID('urn:uuid:12345678-1234-5678-1234-567812345678')
UUID(bytes='\x12\x34\x56\x78'*4)
UUID(bytes_le='\x78\x56\x34\x12\x34\x12\x78\x56' +
              '\x12\x34\x56\x78\x12\x34\x56\x78')
UUID(fields=(0x12345678, 0x1234, 0x5678, 0x12, 0x34, 0x567812345678))
UUID(int=0x12345678123456781234567812345678)
Exactly one of hex, bytes, bytes_le, fields, or int must be given. The version argument is optional; if given, the resulting UUID will have its variant and version number set according to RFC 4122, overriding bits in the given hex, bytes, bytes_le, fields, or int.'''

    # akw.Constructor(
    #     cls=c,
    #     signature=[('ackward::uuid::Hex', 'hex')])
    
    # akw.Constructor(
    #     cls=c,
    #     signature=[('ackward::uuid::Bytes', 'bytes')])

    # akw.Constructor(
    #     cls=c,
    #     signature=[('ackward::uuid::Bytes_LE', 'bytes')])

    # akw.Constructor(
    #     cls=c,
    #     signature=[('ackward::uuid::Fields', 'fields')])

    # akw.Constructor(
    #     cls=c,
    #     signature=[('ackward::uuid::uint128_t', 'integer')])
