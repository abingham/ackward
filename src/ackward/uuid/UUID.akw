# -*- python -*-

import ackward as akw

def definition():
    c = akw.Class(name='UUID',
                  wrapped_class='uuid.UUID')

    akw.Property(
        cls=c,
        name='bytes',
        type='std::string',
        read_only=True)

    akw.Property(
        cls=c,
        name='bytes_le',
        type='std::string',
        read_only=True)

    # akw.Property(
    #     cls=c,
    #     name='fields',
    #     type='ackward::uuid::Fields',
    #     read_only=True)

    akw.Property(
        cls=c,
        name='hex',
        type='std::string',
        read_only=True)

    # akw.Property(
    #     cls=c,
    #     name='integer',
    #     type='uint128_t',
    #     read_only=True)

    akw.Property(
        cls=c,
        name='urn',
        type='std::string',
        read_only=True)

    # akw.Property(
    #     cls=c,
    #     name='variant',
    #     type='ackward::uuid::Variant',
    #     read_only=True)

    akw.Property(
        cls=c,
        name='version',
        type='unsigned short',
        read_only=True)


# UUID.bytes
# The UUID as a 16-byte string (containing the six integer fields in big-endian byte order).
# UUID.bytes_le
# The UUID as a 16-byte string (with time_low, time_mid, and time_hi_version in little-endian byte order).
# UUID.fields
# A tuple of the six integer fields of the UUID, which are also available as six individual attributes and two derived attributes:

# Field	Meaning
# time_low	the first 32 bits of the UUID
# time_mid	the next 16 bits of the UUID
# time_hi_version	the next 16 bits of the UUID
# clock_seq_hi_variant	the next 8 bits of the UUID
# clock_seq_low	the next 8 bits of the UUID
# node	the last 48 bits of the UUID
# time	the 60-bit timestamp
# clock_seq	the 14-bit sequence number
# UUID.hex
# The UUID as a 32-character hexadecimal string.
# UUID.int
# The UUID as a 128-bit integer.
# UUID.urn
# The UUID as a URN as specified in RFC 4122.
# UUID.variant
# The UUID variant, which determines the internal layout of the UUID. This will be one of the integer constants RESERVED_NCS, RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE.
# UUID.version
# The UUID version number (1 through 5, meaningful only when the variant is RFC_4122).

    return c

'''class uuid.UUID([hex[, bytes[, bytes_le[, fields[, int[, version]]]]]])

Create a UUID from either a string of 32 hexadecimal digits, a string of 16 bytes as the bytes argument, a string of 16 bytes in little-endian order as the bytes_le argument, a tuple of six integers (32-bit time_low, 16-bit time_mid, 16-bit time_hi_version, 8-bit clock_seq_hi_variant, 8-bit clock_seq_low, 48-bit node) as the fields argument, or a single 128-bit integer as the int argument. When a string of hex digits is given, curly braces, hyphens, and a URN prefix are all optional. For example, these expressions all yield the same UUID:

UUID('{12345678-1234-5678-1234-567812345678}')
UUID('12345678123456781234567812345678')
UUID('urn:uuid:12345678-1234-5678-1234-567812345678')
UUID(bytes='\x12\x34\x56\x78'*4)
UUID(bytes_le='\x78\x56\x34\x12\x34\x12\x78\x56' +
              '\x12\x34\x56\x78\x12\x34\x56\x78')
UUID(fields=(0x12345678, 0x1234, 0x5678, 0x12, 0x34, 0x567812345678))
UUID(int=0x12345678123456781234567812345678)
Exactly one of hex, bytes, bytes_le, fields, or int must be given. The version argument is optional; if given, the resulting UUID will have its variant and version number set according to RFC 4122, overriding bits in the given hex, bytes, bytes_le, fields, or int.'''

    # akw.Constructor(
    #     cls=c,
    #     signature=[('ackward::uuid::Hex', 'hex')])
    
    # akw.Constructor(
    #     cls=c,
    #     signature=[('ackward::uuid::Bytes', 'bytes')])

    # akw.Constructor(
    #     cls=c,
    #     signature=[('ackward::uuid::Bytes_LE', 'bytes')])

    # akw.Constructor(
    #     cls=c,
    #     signature=[('ackward::uuid::Fields', 'fields')])

    # akw.Constructor(
    #     cls=c,
    #     signature=[('ackward::uuid::uint128_t', 'integer')])
