-*- rst -*-

General
=======

* Consider adding "isNone" or some other way of checking Object
  subclasses for None...or if this is even a reasonable idea. Using
  shared_ptr is also a good option.
* create (or find) "type()" method for python objects
* Check for proper type on C++ object construction, e.g. TimeDelta
  should check the obj parameter, at least in debug mode.
  * We have this functionality, but it doesn't always work e.g. for
    Filter and Handler. The reason, I assume, is that we're passing in
    objects which meet the duck-type but aren't actually
    subclasses. Is it just a bad idea to do this kind of checking at
    all? Maybe we should just warn about mismatches in debug mode or
    something?

Logging
=======

* Quash console output in tests
* LoggerAdapter
* Various handler subclasses
* StreamHandler: construct from things like cout, cerr...any ostream?

Datetime
========

* TimeDelta
  * Done?
* TZInfo
  * TZInfo_ needs to create a subclass of tzinfo for
    customization. Standard tzinfo members are read-only and can't be
    replaced
* Date:
  * finish API
* Time
  * start/implement this
* DateTime
  * Finish API
* Consider writing general-use tm <-> time.struct_time
  converters...useful?

UUID
====
* implement this

Next Version
============

* Subclassing C++ interfaces
  For example::
  
  class MyFormatter : public Formatter
  {
  private:
     // Reimplements standard format() method
     std::wstring format_impl(const LogRecord&) const;
  };

